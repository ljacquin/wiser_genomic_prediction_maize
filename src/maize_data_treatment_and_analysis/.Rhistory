library(mixOmics)
library(data.table)
library(plotly)
library(ggplot2)
library(umap)
library(dplyr)
library(Matrix)
library(graphics)
library(htmlwidgets)
library(rstudioapi)
library(stringr)
library(tidyr)
library(dplyr)
library(lsmeans)
library(lme4)
# detect and set script path automatically, and source functions
setwd(dirname(getActiveDocumentContext()$path))
source("../functions.R")
# set options to increase memory
options(expressions = 5e5)
options(warn = -1)
emm_options(rg.limit = 10e6)
# set path for genomic data and phenotype data
genom_dir_path <- "../../data/genomic_data/"
pheno_dir_path <- "../../data/phenotype_data/"
# set output result path for genomic graphics
output_genom_graphics_path <- "../../results/genomic_prediction_graphics/"
# set maximum number of principal components to be tested using akaike
# information criterion
max_n_comp_ <- 10
# define traits_
traits_ <- c(
"plant.height", "tassel.height", "ear.height",
"anthesis", "silking", "anthesis.silking.interval",
"grain.number", "grain.yield", "grain.weight"
)
# get genomic data
geno_df <- as.data.frame(fread(paste0(
genom_dir_path,
"7a-Genotyping_50K_41722.csv"
)))
row_names_ <- geno_df[, 1]
rownames(geno_df) <- row_names_
geno_df <- geno_df[, -1]
dim(geno_df)
# get phenotype data
pheno_df <- as.data.frame(fread(paste0(
pheno_dir_path,
"2a-GrainYield_components_Plot_level.csv"
)))
# rename columns associated to genotypes and environments
colnames(pheno_df)[
match("Variety_ID", colnames(pheno_df))
] <- "Genotype"
pheno_df$Envir <- paste0(
pheno_df$Experiment,
"_block_", pheno_df$block
)
# replace management types by "R" and "W"
pheno_df <- pheno_df %>%
mutate(Management = ifelse(treatment == "rainfed", "R", "W"))
# apply function to generate row and position columns by environment
pheno_df <- generate_row_column_variables_by_environment(pheno_df)
# get common genotypes between genomic and phenotype data
pheno_df <- match_indices(pheno_df, geno_df)
geno_df <- geno_df[rownames(geno_df) %in% pheno_df$Genotype, ]
dim(geno_df)
length(unique(pheno_df$Genotype))
# write reformatted datasets
fwrite(pheno_df,
file = paste0(pheno_dir_path, "phenotype_data.csv")
)
fwrite(as.data.frame(geno_df),
file = paste0(genom_dir_path, "genomic_data.csv"),
row.names = T
)
# compute blups for traits using pca as fixed covariates for population
# structure correction
geno_pca <- mixOmics::pca(apply(geno_df, 2, as.numeric), ncomp = max_n_comp_)
pc_coord_df_ <- as.data.frame(geno_pca$variates)[, 1:max_n_comp_]
pc_var_names_ <- colnames(pc_coord_df_)
pc_coord_df_$Genotype <- rownames(geno_df)
# initialize list for traits ls-means and blups
blup_list_ <- vector("list", length(traits_))
names(blup_list_) <- traits_
aic_ <- rep(0, max_n_comp_)
for (trait_ in traits_) {
pheno_df_trait_ <- pheno_df[, c(
trait_, "Genotype",
"Envir"
)]
# merge trait individual phenotypes with associated
# pc coordinates for genotypes
pheno_df_trait_ <- merge(pheno_df_trait_, pc_coord_df_,
by = "Genotype", all = TRUE
)
# compute aic values in order to select number of pcs
for (n_comp_ in 1:max_n_comp_) {
print(paste0("n_comp_: ", n_comp_))
lmer_model_ <- lmer(
as.formula(paste0(
trait_,
" ~ 1 + Envir + ", paste(pc_var_names_[1:n_comp_],
collapse = " + "
),
" + (1 | Genotype)"
)),
data = pheno_df_trait_
)
aic_[n_comp_] <- AIC(lmer_model_)
}
n_opt_comp_aic_ <- which.min(aic_)
print(paste0("number of pc selected: ", n_opt_comp_aic_))
# estimate model based on selected number of pcs which minimize aic
lmer_model_ <- lmer(
as.formula(paste0(
trait_,
" ~ 1 + Envir + ", paste(pc_var_names_[1:n_opt_comp_aic_],
collapse = " + "
),
" + (1 | Genotype)"
)),
data = pheno_df_trait_
)
df_ <- data.frame(
"Genotype" = rownames(ranef(lmer_model_)$Genotype),
"BLUP" = as.numeric(unlist(ranef(lmer_model_)$Genotype))
)
blup_list_[[trait_]] <- df_
}
trait_
traits_
View(pheno_df_trait_)
test_ <- pheno_df_trait_[!is.na(pheno_df_trait_$grain.number), ]
test_
length(unique(test_$Genotype))
View(pheno_df)
View(pheno_df_trait_)
is.inf(pheno_df_trait_)
is.infinite(pheno_df_trait_)
is.infinite(pheno_df_trait_$grain.number)
which(is.infinite(pheno_df_trait_$grain.number))
idx_inf <- which(is.infinite(pheno_df_trait_$grain.number))
idx_inf
length(idx_inf)
idx_inf <- which(is.infinite(pheno_df_trait_[,trait_]))
idx_inf
pheno_df_trait_[,trait_]
pheno_df_trait_[idx_inf,trait_]
idx_inf <- which(is.infinite(pheno_df_trait_[,trait_]))
if ( length(idx_inf)> 0 ){
pheno_df_trait_[idx_inf,trait_] <- NA
}
traits_
trait_
traits_left = c("grain.number", "grain.yield", "grain.weight" )
traits_
traits_left
View(blup_list_)
traits_left
for (trait_ in traits_left) {
pheno_df_trait_ <- pheno_df[, c(
trait_, "Genotype",
"Envir"
)]
# merge trait individual phenotypes with associated
# pc coordinates for genotypes
pheno_df_trait_ <- merge(pheno_df_trait_, pc_coord_df_,
by = "Genotype", all = TRUE
)
idx_inf <- which(is.infinite(pheno_df_trait_[,trait_]))
if ( length(idx_inf)> 0 ){
pheno_df_trait_[idx_inf,trait_] <- NA
}
# compute aic values in order to select number of pcs
for (n_comp_ in 1:max_n_comp_) {
print(paste0("n_comp_: ", n_comp_))
lmer_model_ <- lmer(
as.formula(paste0(
trait_,
" ~ 1 + Envir + ", paste(pc_var_names_[1:n_comp_],
collapse = " + "
),
" + (1 | Genotype)"
)),
data = pheno_df_trait_
)
aic_[n_comp_] <- AIC(lmer_model_)
}
n_opt_comp_aic_ <- which.min(aic_)
print(paste0("number of pc selected: ", n_opt_comp_aic_))
# estimate model based on selected number of pcs which minimize aic
lmer_model_ <- lmer(
as.formula(paste0(
trait_,
" ~ 1 + Envir + ", paste(pc_var_names_[1:n_opt_comp_aic_],
collapse = " + "
),
" + (1 | Genotype)"
)),
data = pheno_df_trait_
)
df_ <- data.frame(
"Genotype" = rownames(ranef(lmer_model_)$Genotype),
"BLUP" = as.numeric(unlist(ranef(lmer_model_)$Genotype))
)
blup_list_[[trait_]] <- df_
}
View(blup_list_)
View(blup_list_)
traits_left
styler:::style_active_file()
# reduce blup list
blup_df <- Reduce(
function(x, y) {
merge(x, y,
by = "Genotype",
all = T
)
},
blup_list_
)
colnames(blup_df) <- c("Genotype", traits_)
View(blup_df)
# write blups
fwrite(blup_df, file = paste0(
pheno_dir_path,
"blup_phenotypes.csv"
))
# script meant to correct for spatial heterogenity for all traits
# note: text is formatted from Addins using Style active file from styler package
# clear memory and source libraries
rm(list = ls())
library(reticulate)
library(devtools)
if ("maize_env" %in% conda_list()$name) {
use_condaenv("maize_env")
}
library(tidyverse)
library(tidyr)
library(data.table)
library(lubridate)
library(plotly)
library(htmlwidgets)
library(emmeans)
library(SpATS)
library(stringr)
library(lme4)
library(anytime)
library(foreach)
library(parallel)
library(doParallel)
# define computation mode, i.e. "local" or "cluster"
computation_mode <- "cluster"
# if comutations are local in rstudio, detect and set script path
# automatically using rstudioapi
if (identical(computation_mode, "local")) {
library(rstudioapi)
setwd(dirname(getActiveDocumentContext()$path))
}
# source functions
source("../functions.R")
# set options to increase memory and suppress warnings
options(expressions = 5e5)
options(warn = -1)
# set paths
# input and output data paths
pheno_dir_path_ <- "../../data/phenotype_data/"
pheno_file_path_ <- paste0(
pheno_dir_path_,
"phenotype_data.csv"
)
output_spats_file_path <- paste0(
pheno_dir_path_,
"spats_per_env_adjusted_phenotypes/"
)
# define function(s) and package(s) to export for parallelization
func_to_export_ <- c("fread")
pkgs_to_export_ <- c(
"data.table", "stringr", "SpATS", "lme4",
"lubridate", "emmeans", "plotly", "tidyr", "htmlwidgets"
)
# define selected_traits_ and vars_to_keep_ for output
selected_traits_ <- c(
"plant.height", "tassel.height", "ear.height", "anthesis",
"silking", "anthesis.silking.interval", "grain.number",
"grain.yield", "grain.weight"
)
vars_to_keep_ <- c(
"Envir", "Row", "Column", "Genotype"
)
# colors for boxplots
blue_gradient <- c("#3D9BC5", "#005AB5", "#00407A")
yellow_orange_gradient <- colorRampPalette(c("#149414", "#3b5534"))(3)
bp_colors_ <- c(blue_gradient, yellow_orange_gradient)
# define parameters for computations
min_obs_lmer_ <- 5 # cannot fit lmer if less than that.. Note  5 is pretty small
# and doesn't necessarily make sense either, its somewhat arbitrary
# get pheno_df and detect attributes, e.g. number of modalities or levels for specific variables
pheno_df_ <- as.data.frame(fread(pheno_file_path_))
management_types <- unique(pheno_df_$Management)
n_management <- length(management_types)
# define a list for singular models associated to SpATS
singular_model_list_ <<- vector("list", length(selected_traits_))
names(singular_model_list_) <- selected_traits_
# parallelize treatments for each trait_, for sequential treatment replace %dopar% by %do%
# save and return errors in singular_model_out_vect_
cl <- makeCluster(detectCores())
registerDoParallel(cl)
singular_model_out_vect_ <-
foreach(
trait_ = selected_traits_,
.export = func_to_export_,
.packages = pkgs_to_export_,
.combine = c
) %dopar% {
print(paste0("performing computation for ", trait_))
# keep variables of interest
df_ <- pheno_df_[, c(vars_to_keep_, trait_)]
# get unique environments
env_list_ <- unique(df_$Envir)
# initialize list for spatial heterogeneity correction for each environment
list_spats_envir_ <- vector("list", length(env_list_))
names(list_spats_envir_) <- env_list_
# perform a spatial heterogeneity correction for each environment for trait_
for (env_ in env_list_)
{
list_spats_env_ <- spat_hetero_env_correct_trait(
trait_,
env_,
df_
)
list_spats_envir_[[env_]] <- list_spats_env_$df_envir_
# save environment for which an error occured
if (list_spats_env_$message_ != "no error") {
singular_model_list_[[trait_]] <- c(
singular_model_list_[[trait_]],
paste0(
"Error for ", env_, " during SpATs: ",
list_spats_env_$message_
)
)
}
}
# concatenate list elements for spatial heterogeneity correction into a single df_
df_ <- do.call(rbind, list_spats_envir_)
df_ <- drop_na(df_)
# sort list
singular_model_list_[[trait_]] <-
sort(singular_model_list_[[trait_]], decreasing = T)
# define rename exceptions
exception_cols <- c(
"Genotype", "Envir",
"Row", "Column",
"R", "C", trait_
)
# rename columns excluding the exception columns
new_names <- colnames(df_)
new_names[!(new_names %in% exception_cols)] <- paste0(
trait_, "_", new_names[
!(new_names %in% exception_cols)
]
)
# replace the existing column names with the new names
colnames(df_) <- new_names
# write adjusted phenotype, from spatial heterogeneity correction, to long format
fwrite(df_, paste0(
output_spats_file_path, trait_,
"_spats_adjusted_phenotypes_long_format.csv"
))
return(paste0(
trait_, ": ",
singular_model_list_[[trait_]]
))
}
# stop cluster
stopCluster(cl)
# write errors saved in singular_model_out_vect_
writeLines(singular_model_out_vect_, paste0(
pheno_dir_path_,
"envir_per_trait_with_miss_data_or_singular_spats_model.csv"
))
# script meant to compute lsmeans for all traits
# note: text is formatted from Addins using Style active file from styler package
# clear memory and source libraries
rm(list = ls())
library(reticulate)
library(devtools)
if ("maize_env" %in% conda_list()$name) {
use_condaenv("maize_env")
}
library(tidyverse)
library(tidyr)
library(data.table)
library(lubridate)
library(plotly)
library(htmlwidgets)
library(emmeans)
library(SpATS)
library(stringr)
library(lme4)
library(anytime)
library(foreach)
library(parallel)
library(doParallel)
# define computation mode, i.e. "local" or "cluster"
computation_mode <- "cluster"
# if comutations are local in rstudio, detect and set script path
# automatically using rstudioapi
if (identical(computation_mode, "local")) {
library(rstudioapi)
setwd(dirname(getActiveDocumentContext()$path))
}
# source functions
source("../functions.R")
# set options to increase memory and suppress warnings
options(expressions = 1e5)
emm_options(rg.limit = 5e5)
options(warn = -1)
# set paths
pheno_dir_path_ <- "../../data/phenotype_data/"
pheno_file_path_ <- paste0(
pheno_dir_path_,
"phenotype_data.csv"
)
spats_adj_pheno_path <- paste0(
pheno_dir_path_,
"spats_per_env_adjusted_phenotypes/"
)
# threshold for removing columns with too much na
col_na_thresh_ <- 0.3
# set vars to keep for lsmeans computation
vars_to_keep_ <- c("Envir", "Genotype")
# get file names for spats adjusted phenotypes and replace pattern
# "_spats_adjusted_.*" with "" to get trait names
files_names_spats_adj_pheno <- list.files(spats_adj_pheno_path)
trait_names_ <- str_replace_all(files_names_spats_adj_pheno,
"_spats_adjusted_.*",
replacement = ""
)
# initialize list for lsmeans associated to all traits
list_ls_means_adj_pheno_per_geno <- vector("list", length(trait_names_))
names(list_ls_means_adj_pheno_per_geno) <- trait_names_
# compute lsmeans across all traits
for (file_ in files_names_spats_adj_pheno) {
print(paste0("computation for file : ", file_))
df_ <- as.data.frame(fread(paste0(spats_adj_pheno_path, file_)))
df_ <- df_[, c(vars_to_keep_, colnames(df_)[str_detect(
colnames(df_),
"spats_adj_pheno"
)])]
Y <- colnames(df_)[str_detect(colnames(df_), "spats_adj_pheno")]
if (length(unique(df_$Envir)) > 1) {
# compute adjusted ls-means for genotypes across environments
lm_model <- lm(formula(paste0(Y, "~ Genotype + Envir")), data = df_)
ls_means <- as.data.frame(
lsmeans(lm_model, ~Genotype)
)[, c("Genotype", "lsmean")]
colnames(ls_means)[match("lsmean", colnames(ls_means))] <-
paste0(
str_replace_all(file_, "_spats_adjusted_.*", replacement = ""),
"_lsmean"
)
list_ls_means_adj_pheno_per_geno[[
str_replace_all(file_, "_spats_adjusted_.*",
replacement = ""
)
]] <- ls_means
} else {
# compute adjusted ls-means for genotypes for unique environment
lm_model <- lm(formula(paste0(Y, "~ Genotype")), data = df_)
ls_means <- as.data.frame(
lsmeans(lm_model, ~Genotype)
)[, c("Genotype", "lsmean")]
colnames(ls_means)[match("lsmean", colnames(ls_means))] <-
paste0(
str_replace_all(file_, "_spats_adjusted_.*", replacement = ""),
"_lsmean"
)
list_ls_means_adj_pheno_per_geno[[
str_replace_all(file_, "_spats_adjusted_.*",
replacement = ""
)
]] <- ls_means
}
}
#  merge list of ls_means into a single data frame for genotypes
pheno_df <- Reduce(
function(x, y) {
merge(x, y, by = "Genotype", all = T)
},
list_ls_means_adj_pheno_per_geno
)
# convert merge object to data.frame
pheno_df <- as.data.frame(pheno_df)
na_count <- colSums(is.na(pheno_df))
idx_col_to_drop <- which(na_count / nrow(pheno_df) > col_na_thresh_)
if (length(idx_col_to_drop) > 0) {
pheno_df <- pheno_df[, -idx_col_to_drop]
}
colnames(pheno_df)[str_detect(colnames(pheno_df), "_lsmean")] <-
str_replace_all(
colnames(pheno_df)[str_detect(colnames(pheno_df), "_lsmean")],
pattern = "_lsmean", replacement = ""
)
fwrite(pheno_df,
file = paste0(
pheno_dir_path_,
"adjusted_ls_mean_phenotypes.csv"
)
)
styler:::style_active_file()
